<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Thông số cảm biến</title>
  <script src="https://code.highcharts.com/highcharts.js"></script>
  <script>
    Highcharts.setOptions({ time: { useUTC: false } });
  </script>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #eef9f8;
      margin: 0;
      padding: 0;
    }
    .header {
      background-color: #4eb9b7;
      color: white;
      text-align: center;
      padding: 1rem;
      font-size: 2rem;
      font-weight: bold;
    }
    .chart-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      padding: 1rem;
    }
    .chart-box {
      background: white;
      border-radius: 1rem;
      padding: 1rem;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      width: 90%;
      max-width: 800px;
    }
  </style>
</head>
<body>
  <div class="header">Thông số cảm biến</div>
  <div class="chart-container">
    <div id="voltageChart" class="chart-box"></div>
    <div id="currentChart" class="chart-box"></div>
    <div id="powerChart" class="chart-box"></div>
    <div id="frequencyChart" class="chart-box"></div>
    <div id="tempChart" class="chart-box"></div>
  </div>

  <script>
    const MAX_POINTS = 20;
    const charts = {};
    let isOnline = true;
    let fetchInterval = null;
    const syncKey = 'latest_sensor_data';

    const chartOptions = (title, unit) => ({
      chart: { type: 'spline', animation: Highcharts.svg, marginRight: 10 },
      title: { text: title },
      xAxis: {
        type: 'datetime',
        tickInterval: 30000,
        labels: { format: '{value:%H:%M:%S}' },
        tickPixelInterval: 150
      },
      yAxis: {
        title: { text: unit },
        plotLines: [{ value: 0, width: 1, color: '#808080' }]
      },
      tooltip: {
        formatter: function () {
          return `<b>${this.series.name}</b><br/>` +
                 Highcharts.dateFormat('%H:%M:%S', this.x) +
                 `<br/>Giá trị: ${Highcharts.numberFormat(this.y, 2)} ${unit}`;
        }
      },
      legend: { enabled: true },
      exporting: { enabled: false },
      series: [{
        name: title,
        data: [],
        color: {
          'Voltage': '#f94144',
          'Current': '#f3722c',
          'Power': '#f9c74f',
          'Frequency': '#43aa8b',
          'Temperature': '#577590'
        }[title] || undefined
      }]
    });

    charts.voltage = Highcharts.chart('voltageChart', chartOptions('Voltage', 'V'));
    charts.current = Highcharts.chart('currentChart', chartOptions('Current', 'A'));
    charts.power = Highcharts.chart('powerChart', chartOptions('Power', 'W'));
    charts.frequency = Highcharts.chart('frequencyChart', chartOptions('Frequency', 'Hz'));
    charts.temp = Highcharts.chart('tempChart', chartOptions('Temperature', '°C'));

    function updateChartsFromData(payload) {
      const { timestamp, voltage, current, power, frequency, temp } = payload;
      if (!isNaN(voltage)) charts.voltage.series[0].addPoint([timestamp, voltage], true, charts.voltage.series[0].data.length >= MAX_POINTS);
      if (!isNaN(current)) charts.current.series[0].addPoint([timestamp, current], true, charts.current.series[0].data.length >= MAX_POINTS);
      if (!isNaN(power)) charts.power.series[0].addPoint([timestamp, power], true, charts.power.series[0].data.length >= MAX_POINTS);
      if (!isNaN(frequency)) charts.frequency.series[0].addPoint([timestamp, frequency], true, charts.frequency.series[0].data.length >= MAX_POINTS);
      if (!isNaN(temp)) charts.temp.series[0].addPoint([timestamp, temp], true, charts.temp.series[0].data.length >= MAX_POINTS);
    }

    async function fetchSensorData() {
      try {
        const res = await fetch('/api/sensor', { cache: 'no-store' });
        const d = await res.json();

        if (!d.alive) {
          if (isOnline) {
            isOnline = false;
            clearInterval(fetchInterval);
            fetchInterval = null;
            alert('ESP32 mất kết nối. Đồ thị tạm dừng.');
          }
          return;
        }

        if (!isOnline) {
          isOnline = true;
          alert('ESP32 đã kết nối lại. Tiếp tục cập nhật đồ thị.');
          startFetching();
        }

        const list = d.history || [];
        list.forEach(payload => updateChartsFromData(payload));

        if (list.length > 0) {
          localStorage.setItem(syncKey, JSON.stringify(list[list.length - 1]));
        }
      } catch (e) {
        console.warn('Lỗi khi kết nối tới API: ', e);
        if (isOnline) {
          isOnline = false;
          clearInterval(fetchInterval);
          fetchInterval = null;
        }
      }
    }

    function startFetching() {
      if (fetchInterval) return;
      fetchSensorData();
      const now = new Date();
      const seconds = now.getSeconds();
      const ms = now.getMilliseconds();
      const delayToNext30s = ((30 - (seconds % 30)) % 30) * 1000 - ms;
      setTimeout(() => {
        fetchSensorData();
        fetchInterval = setInterval(fetchSensorData, 30000);
      }, delayToNext30s);
    }

    window.addEventListener('storage', (event) => {
      if (event.key === syncKey && event.newValue) {
        const data = JSON.parse(event.newValue);
        updateChartsFromData(data);
      }
    });

    window.addEventListener('beforeunload', () => {});
    startFetching();
  </script>
</body>
</html>
